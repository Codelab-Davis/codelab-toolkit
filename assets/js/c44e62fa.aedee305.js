"use strict";(self.webpackChunktmp=self.webpackChunktmp||[]).push([[687],{966:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>r});var o=s(1527),c=s(7463);s(6533);const a={title:"useMemo and useCallback Hooks",description:"Optimization"},i="useMemo and useCallback Hooks: Optimization",t={id:"guide/useMemoUseCallback",title:"useMemo and useCallback Hooks",description:"Optimization",source:"@site/docs/guide/useMemoUseCallback.mdx",sourceDirName:"guide",slug:"/guide/useMemoUseCallback",permalink:"/codelab-toolkit/docs/guide/useMemoUseCallback",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"useMemo and useCallback Hooks",description:"Optimization"},sidebar:"guideSidebar",previous:{title:"Custom Hooks",permalink:"/codelab-toolkit/docs/guide/customHooks"},next:{title:"Authentication with NextAuth",permalink:"/codelab-toolkit/docs/guide/authentication"}},l={},r=[{value:"Introduction",id:"introduction",level:2},{value:"<code>useMemo</code>: Cached Values",id:"usememo-cached-values",level:2},{value:"How to use <code>useMemo</code>",id:"how-to-use-usememo",level:3},{value:"When to use <code>useMemo</code>",id:"when-to-use-usememo",level:3},{value:"When NOT to use <code>useMemo</code>",id:"when-not-to-use-usememo",level:3},{value:"<code>useCallback</code>: Cached Functions",id:"usecallback-cached-functions",level:2},{value:"How to use <code>useCallback</code>",id:"how-to-use-usecallback",level:3},{value:"When to use <code>useCallback</code>",id:"when-to-use-usecallback",level:3},{value:"Additional Resources",id:"additional-resources",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"usememo-and-usecallback-hooks-optimization",children:"useMemo and useCallback Hooks: Optimization"}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.p,{children:"Don\u2019t Optimize Prematurely!\nOverusing these hooks could actually lead to worse performance."})}),"\n",(0,o.jsxs)(n.p,{children:["As apps get larger, it becomes increasingly important to optimize performance. Two of the most important React Hooks for performance optimization are ",(0,o.jsx)(n.code,{children:"useMemo"})," and ",(0,o.jsx)(n.code,{children:"useCallback"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useMemo"})," returns a memoized value, which is a cached value that is only recalculated when its dependencies change. This can be useful for avoiding unnecessary re-renders, especially when performing expensive calculations or fetching data."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useCallback"})," returns a memoized callback function, which is a function that is only recreated when its dependencies change. This can be useful for preventing unnecessary re-renders of child components when passing callback functions as props."]}),"\n",(0,o.jsxs)(n.p,{children:["By using ",(0,o.jsx)(n.code,{children:"useMemo"})," and ",(0,o.jsx)(n.code,{children:"useCallback"})," wisely, you can improve the performance of your React applications and provide a better user experience."]}),"\n",(0,o.jsxs)(n.h2,{id:"usememo-cached-values",children:[(0,o.jsx)(n.code,{children:"useMemo"}),": Cached Values"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useMemo"})," hook in React is used to cache variables between re-renders. Usually, variables will be recalcuated if they are within the scope of the re-render, but for some variables this can be inefficient since they are expensive to calculate."]}),"\n",(0,o.jsxs)(n.h3,{id:"how-to-use-usememo",children:["How to use ",(0,o.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useMemo"})," is a hook that takes two arguments:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Calculation function: a function that returns what value you want to calculate"}),"\n",(0,o.jsx)(n.li,{children:"Dependencies: A list of items that, when changed, will cause a recalculation of the value"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Here is an example where we are sorting some notes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const sortedNotes = useMemo(() => notes.sort(), [notes]);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When the ",(0,o.jsx)(n.code,{children:"notes"})," variables changes, the ",(0,o.jsx)(n.code,{children:"sortedNotes"})," variable will recalculate itself."]}),"\n",(0,o.jsxs)(n.h3,{id:"when-to-use-usememo",children:["When to use ",(0,o.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useMemo"})," should be used when you have a expensive calculation. A good example of an expensive calculation is the ",(0,o.jsx)(n.code,{children:"filter"})," function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const evenNumbers = numbers.filter((number) => number % 2 === 0);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For large datasets, recalculating a value like this on every re-render is expensive, so we should wrap it in a ",(0,o.jsx)(n.code,{children:"useMemo"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const evenNumbers = useMemo(\n    () => numbers.filter((number) => number % 2 === 0),\n    [numbers]\n);\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["Note that even if it is an expensive calculation, other factors such as dataset size affect the actual performance of the app. Just because a calculation is expensive does NOT necessarily mean it should automatically be wrapped in a ",(0,o.jsx)(n.code,{children:"useMemo"}),"."]})}),"\n",(0,o.jsxs)(n.p,{children:["It is also useful for ",(0,o.jsx)(n.code,{children:"useMemo"})," to be used for a value that is a dependency of another hook. The memoized value can help avoid both its own recalculation and the recalculation of the dependent hook."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'const memoizedValue = useMemo(() => {\n    // This is an expensive calculation.\n    return Math.pow(10, count);\n}, [count]);\n\n// This hook depends on the memoized value.\nuseEffect(() => {\n    console.log("Memoized value:", memoizedValue);\n}, [memoizedValue]);\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"when-not-to-use-usememo",children:["When NOT to use ",(0,o.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,o.jsxs)(n.p,{children:["In general, ",(0,o.jsx)(n.code,{children:"useMemo"})," shouldn\u2019t be used until the developer is sure that its addition will optimize the app. Usually some amount of manual testing is needed to determine if ",(0,o.jsx)(n.code,{children:"useMemo"})," is or isn\u2019t needed in an app."]}),"\n",(0,o.jsxs)(n.p,{children:["But to be more specific, it is not usually necessary to use ",(0,o.jsx)(n.code,{children:"useMemo"})," on inexpensive calculations, such as basic arithmetic:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const half = const half = numbers / 2;\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"usecallback-cached-functions",children:[(0,o.jsx)(n.code,{children:"useCallback"}),": Cached Functions"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useCallback"})," is a React Hook that returns a memoized callback function. A memoized callback function is a function that is only recreated when its dependencies change. This can be useful for preventing unnecessary re-renders of child components when passing callback functions as props."]}),"\n",(0,o.jsxs)(n.h3,{id:"how-to-use-usecallback",children:["How to use ",(0,o.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useCallback"})," hook takes two arguments:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Callback function:"}),"\xa0A function that you want to memoize."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dependencies:"}),"\xa0An array of dependencies. The\xa0",(0,o.jsx)(n.code,{children:"useCallback"}),"\xa0hook will only recreate the callback function if any of the dependencies change."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Here is an example of how to use the ",(0,o.jsx)(n.code,{children:"useCallback"})," hook:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const doSomethingWithNumber = useCallback(\n    () => doSomething(magicNumber),\n    [magicNumber]\n);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now, ",(0,o.jsx)(n.code,{children:"doSomethingWithNumber"})," is a callback function that calls another function onto the variable ",(0,o.jsx)(n.code,{children:"magicNumber"}),". It recreates itself whenever ",(0,o.jsx)(n.code,{children:"magicNumber"})," changes, since the function would do something different then."]}),"\n",(0,o.jsxs)(n.h3,{id:"when-to-use-usecallback",children:["When to use ",(0,o.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,o.jsxs)(n.p,{children:["It\u2019s generally recommended to wrap a function in a ",(0,o.jsx)(n.code,{children:"useCallback"})," if:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["It is a dependency of another ",(0,o.jsx)(n.code,{children:"useMemo"})," or ",(0,o.jsx)(n.code,{children:"memo"})," and you don\u2019t want the function to cause unnecessary re-renders"]}),"\n",(0,o.jsxs)(n.li,{children:["It is a dependency of another hook, like ",(0,o.jsx)(n.code,{children:"useEffect"})," so that it does not recalculate unnecessarily"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,o.jsxs)(n.p,{children:["If you would like to learn more about ",(0,o.jsx)(n.code,{children:"useMemo"}),", please refer to the ",(0,o.jsx)(n.a,{href:"https://react.dev/reference/react/useMemo",children:"official React documentation"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If you would like to learn more about ",(0,o.jsx)(n.code,{children:"useCallback"}),", please refer to the ",(0,o.jsx)(n.a,{href:"https://react.dev/reference/react/useCallback",children:"official React documentation"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},6533:(e,n,s)=>{s.d(n,{Z:()=>c});s(959);var o=s(1527);const c=e=>{let{src:n}=e;return(0,o.jsx)("div",{className:"flex h-[500px] rounded border",children:(0,o.jsx)("iframe",{src:n,className:"h-full w-full",frameborder:"0"})})}},7463:(e,n,s)=>{s.d(n,{Z:()=>t,a:()=>i});var o=s(959);const c={},a=o.createContext(c);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);